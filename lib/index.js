// Generated by CoffeeScript 1.12.6
(function() {
  var Connector, EventEmitter, LyncDisableFeedback, LyncEventEmitter, LyncLauncher, LyncManager, _, child_process, debug, moment,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  child_process = require('child_process');

  EventEmitter = require('events').EventEmitter;

  _ = require('lodash');

  moment = require('moment');

  debug = require('debug')('meshblu-connector-skype:index');

  LyncEventEmitter = require('./lync-event-emitter');

  LyncLauncher = require('./lync-launcher');

  LyncDisableFeedback = require('./lync-disable-feedback');

  LyncManager = require('./lync-manager');

  Connector = (function(superClass) {
    extend(Connector, superClass);

    function Connector(arg) {
      this.Lync = arg.Lync;
      this._startVideo = bind(this._startVideo, this);
      this._handleVideoEnabled = bind(this._handleVideoEnabled, this);
      this._handleMeeting = bind(this._handleMeeting, this);
      this._handleAudioEnabled = bind(this._handleAudioEnabled, this);
      this._computeState = bind(this._computeState, this);
      this._emitUpdate = bind(this._emitUpdate, this);
      this._emitNoClient = bind(this._emitNoClient, this);
      this._refreshCurrentState = bind(this._refreshCurrentState, this);
      this.updateDesiredState = bind(this.updateDesiredState, this);
      this.truthAndReconcilliation = bind(this.truthAndReconcilliation, this);
      this.startMeeting = bind(this.startMeeting, this);
      this.killFeedback = bind(this.killFeedback, this);
      this.onConfig = bind(this.onConfig, this);
      this.close = bind(this.close, this);
      this.start = bind(this.start, this);
      if (this.Lync == null) {
        this.Lync = LyncManager;
      }
      this.lyncEventEmitter = new LyncEventEmitter();
    }

    Connector.prototype.start = function(device, callback) {
      this._killFeedbackInterval = setInterval(this.killFeedback, 1000);
      this.lyncEventEmitter.on('config', this.truthAndReconcilliation);
      this.lyncEventEmitter.on('config', _.throttle(((function(_this) {
        return function() {
          return _this._refreshCurrentState();
        };
      })(this)), 1000));
      LyncDisableFeedback.disable((function(_this) {
        return function(error) {
          if (error != null) {
            return callback(error);
          }
        };
      })(this));
      this.uuid = device.uuid;
      return this.onConfig(device, (function(_this) {
        return function(error) {
          if (error) {
            return callback(error);
          }
          return _this._refreshCurrentState(callback);
        };
      })(this));
    };

    Connector.prototype.close = function(callback) {
      clearInterval(this._killFeedbackInterval);
      return callback();
    };

    Connector.prototype.onConfig = function(arg, callback) {
      var autoLaunchSkype, desiredState, ref;
      ref = arg != null ? arg : {}, desiredState = ref.desiredState, autoLaunchSkype = ref.autoLaunchSkype;
      callback();
      this.Lync.emitEvents(this.lyncEventEmitter.handle);
      if (_.isEmpty(desiredState)) {
        return;
      }
      this.desiredState = desiredState;
      this.updateDesiredState({});
      this.truthAndReconcilliation();
      if (autoLaunchSkype === true) {
        return LyncLauncher.autoCheck();
      } else {
        return LyncLauncher.stopAutoCheck();
      }
    };

    Connector.prototype.killFeedback = function() {
      return child_process.exec('taskkill /fi "WINDOWTITLE eq Skype for Business"');
    };

    Connector.prototype.startMeeting = function(arg, callback) {
      var audioEnabled, finishStartMeetingHandler, videoEnabled;
      audioEnabled = arg.audioEnabled, videoEnabled = arg.videoEnabled;
      finishStartMeetingHandler = (function(_this) {
        return function(conversations) {
          var conversationUrl, currentState;
          currentState = _.first(_.values(conversations));
          conversationUrl = _.get(currentState, 'properties.conferenceAccessInformation.ExternalUrl');
          if (conversationUrl) {
            _this.lyncEventEmitter.off('config', finishStartMeetingHandler);
            return callback(null, {
              meeting: {
                url: conversationUrl
              }
            });
          }
        };
      })(this);
      return this.Lync.stopMeetings(null, (function(_this) {
        return function(error) {
          if (error != null) {
            console.error('@Lync.stopMeetings', error.stack);
          }
          _this.lyncEventEmitter.on('config', finishStartMeetingHandler);
          return _this.updateDesiredState({
            audioEnabled: audioEnabled,
            videoEnabled: videoEnabled,
            meeting: {}
          });
        };
      })(this));
    };

    Connector.prototype.truthAndReconcilliation = function() {
      var currentState;
      currentState = _.first(_.values(this.lyncEventEmitter.conversations));
      debug("truthAndReconcilliation", {
        currentState: currentState,
        desiredState: this.desiredState
      });
      if (this.desiredState == null) {
        return;
      }
      this._handleMeeting(currentState, (function(_this) {
        return function(error) {
          if (error != null) {
            console.error('@_handleMeeting', error.stack);
          }
          return delete _this.desiredState.meeting;
        };
      })(this));
      this._handleAudioEnabled(currentState);
      return this._handleVideoEnabled(currentState);
    };

    Connector.prototype.updateDesiredState = function(desiredState) {
      return this.emit('update', {
        desiredState: desiredState
      });
    };

    Connector.prototype._refreshCurrentState = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this._computeState((function(_this) {
        return function(error, state) {
          if (error != null) {
            return callback(error);
          }
          return _this._emitUpdate({
            state: state
          }, callback);
        };
      })(this));
    };

    Connector.prototype._emitNoClient = function(arg, callback) {
      var state;
      state = arg.state;
      this.emit('error', new Error('Cannot find running Lync Process'));
      return this._emitUpdate({
        state: state
      }, callback);
    };

    Connector.prototype._emitUpdate = function(update, callback) {
      if (_.isEqual(update, this._previousUpdate)) {
        return callback();
      }
      this.emit('update', _.defaults({
        connectorUpdatedAt: moment().utc().toISOString()
      }, update));
      this._previousUpdate = update;
      return callback();
    };

    Connector.prototype._computeState = function(callback) {
      var conversationUrl, currentState, ourKindaState, ref, self, videoState;
      debug('_computeState');
      currentState = _.first(_.values(this.lyncEventEmitter.conversations));
      if (currentState == null) {
        return callback(null, {
          meeting: null
        });
      }
      conversationUrl = _.get(currentState, 'properties.conferenceAccessInformation.ExternalUrl');
      if (_.isEmpty(conversationUrl)) {
        conversationUrl = null;
      }
      self = (ref = currentState.participants) != null ? ref[currentState.self] : void 0;
      videoState = _.get(currentState, 'video.state');
      ourKindaState = {
        meeting: {
          url: conversationUrl,
          subject: _.get(currentState, 'subject'),
          participants: _.get(currentState, 'participants')
        },
        conversationId: _.get(currentState, 'properties.id'),
        videoState: _.get(currentState, 'video.state'),
        videoEnabled: videoState === 'Send' || videoState === 'SendReceive',
        videoActions: _.get(currentState, 'video.actions'),
        audioEnabled: !(self != null ? self.isMuted : void 0)
      };
      return callback(null, ourKindaState);
    };

    Connector.prototype._handleAudioEnabled = function(currentState, callback) {
      var self;
      if (callback == null) {
        callback = function() {};
      }
      debug('_handleAudioEnabled', {
        currentState: currentState,
        desiredState: this.desiredState
      });
      if (!_.has(this.desiredState, 'audioEnabled')) {
        return callback();
      }
      if (!_.has(currentState, 'self')) {
        return callback();
      }
      if (_.lowerCase(currentState != null ? currentState.state : void 0) !== 'active') {
        return callback();
      }
      self = _.get(currentState, "participants." + currentState.self);
      debug(this.desiredState.audioEnabled, self.isMuted);
      if (this.desiredState.audioEnabled) {
        debug('unmuting');
        return this.Lync.unmute(null, (function(_this) {
          return function(error) {
            debug('unmuted', error);
            if (error != null) {
              return callback(error);
            }
            delete _this.desiredState.audioEnabled;
            return callback();
          };
        })(this));
      }
      debug('muting');
      return this.Lync.mute(null, (function(_this) {
        return function(error) {
          debug('muted', error);
          if (error != null) {
            return callback(error);
          }
          delete _this.desiredState.audioEnabled;
          return callback();
        };
      })(this));
    };

    Connector.prototype._handleMeeting = function(currentState, callback) {
      var conversationUrl, meeting;
      if (callback == null) {
        callback = function() {};
      }
      debug('_handleMeeting', {
        desiredState: this.desiredState,
        currentState: currentState
      });
      meeting = this.desiredState.meeting;
      delete this.desiredState.meeting;
      if (meeting === void 0) {
        return callback();
      }
      if (meeting === null) {
        return this.Lync.stopMeetings(null, callback);
      }
      conversationUrl = _.get(currentState, 'properties.conferenceAccessInformation.ExternalUrl');
      if (conversationUrl && meeting.url === conversationUrl) {
        return callback();
      }
      debug('stopping meetings');
      return this.Lync.stopMeetings(null, (function(_this) {
        return function(error) {
          if (error != null) {
            return callback(error);
          }
          if (_.isEmpty(meeting.url)) {
            return _this.Lync.createMeeting(null, callback);
          }
          return _this.Lync.joinMeeting(meeting.url, callback);
        };
      })(this));
    };

    Connector.prototype._handleVideoEnabled = function(currentState, callback) {
      if (callback == null) {
        callback = function() {};
      }
      debug('_handleVideoEnabled', this.desiredState);
      if (!_.has(this.desiredState, 'videoEnabled')) {
        return callback();
      }
      if (_.lowerCase(currentState != null ? currentState.state : void 0) !== 'active') {
        return callback();
      }
      if (!this.desiredState.videoEnabled) {
        return this.Lync.stopVideo(null, callback);
      }
      return this._startVideo(currentState, callback);
    };

    Connector.prototype._startVideo = function(currentState, callback) {
      var videoState;
      debug("trying to _startVideo");
      videoState = _.get(currentState, 'video.state');
      if (videoState === 'Send' || videoState === 'SendReceive') {
        debug("videoState was " + videoState + ". We're done!");
        delete this.desiredState.videoEnabled;
        return callback();
      }
      if (_.get(currentState, 'modality.state') !== 'Connected') {
        debug('not connected. waiting till next time');
        return callback();
      }
      if (!(_.get(currentState, 'video.actions.Start') || _.get(currentState, 'video.actions.Resume'))) {
        debug("I can't resume or start the video. waiting until next time");
        return callback();
      }
      debug("Starting video");
      return this.Lync.startVideo(null, callback);
    };

    return Connector;

  })(EventEmitter);

  module.exports = Connector;

}).call(this);

//# sourceMappingURL=index.js.map
